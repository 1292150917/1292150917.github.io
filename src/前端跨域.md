# 前端跨域

## 首先我们解析一个完整的URL地址为http://baidu.com:80

* http:// 
    >协议
* baidu 
    >域名
* com 
    >后缀
* 80
    >端口号

### 常见跨域场景

    > [http://baidu.com] vs https://baidu.com (不同端口跨域)

    > http://baidu.com:80 vs http://baidu.com:8080 (不同端口跨域)

    > http://baiduApp.com vs http://baidu.com (不同域名)

    > http://app.baidu.com vs http://baidu.com (主域名不同 - 子域名)

## 同源策略

[同源策略](https://baike.baidu.com/item/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/3927875?fr=aladdin)/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

## 虽然同源限制可以有效的防止网络上的恶意攻击，但是在实际开发应用中，我们往往需要从本站点向第三方站点发送XHR请求，这就需要有效的解决跨域问题，可以有以下几种：

### 先介绍，后细聊，本文仅提供几种本菜常用的几种方法（不代表解决办法只有这几项）

1、 通过jsonp跨域
*   > 浏览器只对XHR(XMLHttpRequest)请求有同源请求限制，而对script标签src属性、link标签ref属性和img标签src属性没有这这种限制，利用这个“漏洞”就可以很好的解决跨域请求。JSONP就是利用了script标签无同源限制的特点来实现的，当向第三方站点请求时，我们可以将此请求放在script标签的src属性里，这就如同我们请求一个普通的JS脚本，可以自由的向不同的站点请求，此方法需要后端支持
2、 nodejs中间件代理跨域（俗称webpack-dev-server）
*   > 通过[webpack-dev-server](https://www.webpackjs.com/configuration/dev-server/)的参数proxy设置代理域名 （此方法在使用vue/cli，react）的时候会很方便使用！
3、 跨域资源共享（CORS）
*   > 通俗来讲：后端设置[Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)请求头，允许我们本地的ip通过或者设置*全部通过
4、 nginx代理跨域
*   > 说到nginx，不得不说真的很强大，也带来很多便利用于解决一些头疼的难题，一般来说可以用来做：静态页面的服务器、静态文件缓存服务器、网站反向代理、负载均衡服务器等等，而且实现这一切，基本只需要改改那万能的配置文件即可，下方详细介绍吧 这里不方便介绍太多
5、 window.name + iframe跨域
*   >  window.name属性有这样的特点:当前页设置的值, 在页面重新加载(非同域也可以)后, 值依然不变.

### 通过jsonp跨域

* 需要后端做相应的支持，返回jsonp格式的数据
* 只支持GET，不支持POST请求

```javascript

//展示方法,打印跨域数据
var show = function(data){
    console.log(data);
};

//原生jsonp简单实现,动态添加script引用 新增一个callback返回就好了 
var jsonp = function(url,callback){
  var jsonpScript=document.createElement('script');
  jsonpScript.setAttribute('src', `${url}&callback=${callback}`);
  document.getElementsByTagName('head')[0].appendChild(jsonpScript);
}

// 此处需要换上自己的域名地址
jsonp("https://zz9.com/api","show")

```

### webpack-dev-server
